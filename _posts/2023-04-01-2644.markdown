---
layout: post
title:  백준[촌수계산]
date:   2023-04-01 00:30:36 +0900
category: CodingTest
---

이문제에서 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하라고 했기 때문에 DFS 알고리즘으로 풀어야겠다고 생각했다. 

실버2는 처음 풀어보긴 하는데 생각보다 쉽게 풀리는듯(?) 했으나 역시나 막혀버렸다 ... :sweat:

<br/>
<br/>

## DFS (깊이 우선 탐색)

말 그대로 깊은 부분을 우선적으로 탐색하는 알고리즘 
- 보통 재귀함수를 사용해서 구현함 
> ### 그래프
> - 다수의 노드를 방문하는 것 
> - 노드(정점), 간선
> - <span style="color:red">인접 행렬</span>: 2차원 배열로, 그래프의 연결 관계를 표현하는 방식
>   - 2차원 배열에 각 노드가 연결된 형태 -> 파이썬에서 2차원 리스트로 구현할 수 있음! 
>   - 연결이 안되어 있는 노드끼리는 무한의 비용이라고 작성(INF)
> - <span style="color:red">인접 리스트</span>: 리스트로 그래프의 연결 관계를 표현하는 방식
>   - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장 
>    - 연결 리스트 사용
>    - 연결된 정보만 저장하기 때문에 메모리를 효율적으로 사용함 
>    - 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림, 하나하나 다 확인해야 하기 때문에

### DFS의 작동 방식 
특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후 다시 돌아가 다른 경로로 탐색하는 알고리즘
> 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 함.
> 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 잇으면 그 인접 노드를 스택에 넣고 방문 처리를 함. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄. 
> 3. 2번의 과정을 더 이상 수행할 수 없을때까지 반복. 

정리해보면 
시작점에서 더이상 갈 수 없을 때까지 탐색하고, 더 갈 곳이 없다면 이전의 경로로 되돌아감. 
<br/>
<br/>

-----
<br>



- 재귀함수
    
    -> 재귀의 최대 깊이를 초과했다는 내용의 메시지 발생할 수 있음 ( 호출 횟수 제한이 잇음))
        
        RecursionError: maximum recursion depth exceeded while pickling an object

    - 프랙털 이미지를 출력하는 프로그램, 팩토리얼 
    - 종료 조건이 무조건 필요함
        - 스택 자료 구조를 이용 
            - 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료됨

    - 코드의 간결성을 확인할 수 있음 

<br/>
<br/>

-------

<br/>
나는 재귀함수를 정말 잘 못쓰는 것 같아서 dfs를 구현할때 최대한 재귀함수를 사용해보려고 한다. :wink: 


<br/>
### 1차 도전
<br/>

### dfs 함수 
먼저 dfs 함수를 구현해줬다. 
relation_list에 
```py
def dfs(relation_list, root_node, visited=[], result=[]):
    visited.append(root_node)
    for i in range(len(relation_list)):
        if relation_list[i][0] == root_node: 
            if relation_list[i][1] not in visited:
                dfs(relation_list, relation_list[i][1], visited, result)
    print("kkk")
    print(result)
    return visited
```



<script src="https://gist.github.com/Sunjung-Dev/8b02bdea041dedab27466d34499ae1b5.js"></script>